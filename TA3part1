section .text
global _start

_start:
    ;first number prompt
    mov eax, 4
    mov ebx, 1
    mov ecx, prompt1
    mov edx, len_prompt1
    int 0x80

    ;read firstnum
    mov eax, 3
    mov ebx, 0
    mov ecx, num1
    mov edx, 2
    int 0x80

    ;num1 prompt
    mov eax, 4
    mov ebx, 1
    mov ecx, prompt2
    mov edx, len_prompt2
    int 0x80

    ;num2 read
    mov eax, 3
    mov ebx, 0
    mov ecx, num2
    mov edx, 2
    int 0x80

    ;convert ascii to int
    movzx eax, byte [num1]
    sub eax, '0'
    mov [num1_int], eax

    movzx eax, byte [num2]
    sub eax, '0'
    mov [num2_int], eax

    ;perform calculation
    call calculate_addition
    call calculate_subtraction
    call calculate_multiplication
    call calculate_division

    ;display results
    call display_results

    ; ===== Exit =====
    mov eax, 1
    xor ebx, ebx
    int 0x80


;addition
calculate_addition:
    movzx eax, byte [num1_int]
    movzx ebx, byte [num2_int]
    add eax, ebx

    mov ecx, 10
    xor edx, edx
    div ecx              ; eax/10 - eax=quotient, edx=remainder

    cmp eax, 0
    je .single_digit_add

    add eax, '0'
    mov [add_result], al
    add edx, '0'
    mov [add_result+1], dl
    mov byte [add_len], 2
    ret

.single_digit_add:
    add edx, '0'
    mov [add_result], dl
    mov byte [add_len], 1
    ret


;subtraction
calculate_subtraction:
    movzx eax, byte [num1_int]
    movzx ebx, byte [num2_int]
    cmp eax, ebx
    jge .positive

    sub ebx, eax
    mov eax, ebx
    mov byte [sub_sign], '-'
    jmp .convert

.positive:
    sub eax, ebx
    mov byte [sub_sign], ' '

.convert:
    add eax, '0'
    mov [sub_result], al
    ret


;multiplication
calculate_multiplication:
    movzx eax, byte [num1_int]
    movzx ebx, byte [num2_int]
    imul ebx              ; 32-bit multiply

    mov ecx, 10
    xor edx, edx
    div ecx               ; eax/10

    cmp eax, 0
    je .single_digit_mul

    add eax, '0'
    mov [mul_result], al
    add edx, '0'
    mov [mul_result+1], dl
    mov byte [mul_len], 2
    ret

.single_digit_mul:
    add edx, '0'
    mov [mul_result], dl
    mov byte [mul_len], 1
    ret


; division
calculate_division:
    movzx eax, byte [num1_int]
    movzx ebx, byte [num2_int]
    cmp ebx, 0
    je .div_zero

    xor edx, edx
    div ebx               ; eax/ebx - quotient in eax, remainder in edx

    add eax, '0'
    mov [div_quotient], al
    add edx, '0'
    mov [div_remainder], dl
    mov byte [div_valid], 1
    ret

.div_zero:
    mov byte [div_valid], 0
    ret


; disp results
display_results:
    ; Newline
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    ; Addition
    mov eax, 4
    mov ebx, 1
    mov ecx, add_msg
    mov edx, len_add_msg
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, add_result
    movzx edx, byte [add_len]
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    ; Subtraction
    mov eax, 4
    mov ebx, 1
    mov ecx, sub_msg
    mov edx, len_sub_msg
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, sub_sign
    mov edx, 1
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, sub_result
    mov edx, 1
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    ; Multiplication
    mov eax, 4
    mov ebx, 1
    mov ecx, mul_msg
    mov edx, len_mul_msg
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, mul_result
    movzx edx, byte [mul_len]
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    ; Division
    mov eax, 4
    mov ebx, 1
    mov ecx, div_msg
    mov edx, len_div_msg
    int 0x80

    cmp byte [div_valid], 0
    je .div_error

    mov eax, 4
    mov ebx, 1
    mov ecx, div_quotient
    mov edx, 1
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, remainder_msg
    mov edx, len_remainder_msg
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, div_remainder
    mov edx, 1
    int 0x80
    jmp .div_done

.div_error:
    mov eax, 4
    mov ebx, 1
    mov ecx, error_msg
    mov edx, len_error_msg
    int 0x80

.div_done:
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80
    ret


; data
section .data
    prompt1 db "Enter first number (0-9): "
    len_prompt1 equ $ - prompt1

    prompt2 db "Enter second number (0-9): "
    len_prompt2 equ $ - prompt2

    add_msg db "Addition: "
    len_add_msg equ $ - add_msg

    sub_msg db "Subtraction: "
    len_sub_msg equ $ - sub_msg

    mul_msg db "Multiplication: "
    len_mul_msg equ $ - mul_msg

    div_msg db "Division: "
    len_div_msg equ $ - div_msg

    remainder_msg db " Remainder: "
    len_remainder_msg equ $ - remainder_msg

    error_msg db "Error: Division by zero!"
    len_error_msg equ $ - error_msg

    newline db 0xA


section .bss
    num1 resb 2
    num2 resb 2
    num1_int resb 4
    num2_int resb 4
    add_result resb 2
    add_len resb 1
    sub_result resb 1
    sub_sign resb 1
    mul_result resb 2
    mul_len resb 1
    div_quotient resb 1
    div_remainder resb 1
    div_valid resb 1
